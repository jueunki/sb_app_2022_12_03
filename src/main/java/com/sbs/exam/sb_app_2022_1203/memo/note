alt + 1 : 프로젝트 창 열었다 닫았다 하는것.
ctrl + shift + r : 파일명으로 검색이 가능하다.
ctrl + shift + F10 : 실행.
ctrl + shift + f : 소스코드 정렬.
ctrl + 1 : 오류가 났을때 누르면 insert return이라고 있는데 오류메시지를 고쳐준다.
sout + enter : System.out.println(); 코드를 자동완성 시켜준다. 일일이 작성하지 않아도 된다.

-----------------------------------------------------------------------------------------

이렇게 되어있지않으면 실행이 되지않는다. 둘다 항상 있어야한다. 실수로 지웠다면 작성해줘야 실행 할 수 있다.
public class Main {
    public static void main(String[] args) {


	}
}


-----------------------------------------------------------------------------------------



git init
git remote add origin [원격리포지터리 주소]
git config --globar user.name [이름]
git config --globar user.email [이메일]
git status
git add .
git commit -m "세팅"
git push orgin master


-----------------------------------------------------------------------------------------

MVC
C	controller			말도 안되는거 걸러내는 부분
M	service, repository, db	핵심로직을 다룬다(요리사), repository(db와의 통신을 담당한다.), db(창고)
V	jsp				데이터를 템플릿에 담에서

controller(직원)
service(요리사)
repository(인턴)
db(창고)
컨트롤러에서 말도안되는걸 걸러내고 서비스가 레포지토리에게 디비에서 데이터를 가져오라고 시킨다. 요리해서 컨트롤러가 jsp 뷰에게 요리를 보여준다.
request 요청을하면 브라우저로 간다

MVC 디자인 패턴
M(모델:요리,재료,재료창고)핵심로직을 담당한다
V(뷰:접시(플레이팅))
C(컨트롤러:점원)
--
사람으로 예시를 들었을때
M(영혼)
V(육체)
C(정신,마음,생각)
--
컴퓨터로 예시를 들었을때
M(순수 데이터,로직)
V(프로그램의 눈에 보이는 부분)
C(고객의 요청을 받아서 M과 C를 컨트롤 한다.)
C->M->C->V 순서!
---------------------------
Spring boot의 MVC

M
-서비스
-리포지터리
-DB데이터

V
-JSP
-JS
-CSS
-HTML

C
-컨트롤러
----------------------------------------------
/user.article.doAdd?title=제목1&body=내용1





스프링부트 : 웹프레임워크인데 잘 활용하려면 규칙에 맞게 따라야한다.
컨트롤러 - 서비스 - 리포지터리 - 데이터베이스의 구조로 되어있다.
좌에서 우로만 요청할 수 있다/컨트롤러에서 서비스에게 요청할 수 있고 서비스는 컨트롤러에게 응답만 할 수 있다. 요청은 컨트가 서비스에게만!!
서비스는 자기 의지대로 컨트롤러에게 일을 시킬수 없다
서비스에 있는 로직은 리포지터리에게만 넘길수있다.
-------------------------------------------
==error==
fatal: The current branch master has no upstream branch. To push the current branch and set the remote as upstream, use
git push --set-upstream orgin master  To have this happen automatically for branches without a tracking upstream, see 'push.autoSetupRemote' in 'git help config'.

$ git push --set-upstream origin master
$ git push
-------------------------------------------
==검색할것들==
소프트웨어 디자인 패턴 -> 검색
GOF -> 검색 정처기 시험칠때 많이 봐야한다.

-------------------------------------------
@Autowired  //컴포넌트로 등록되는 것들에게 붙여주면 된다.
객체를 만드는부분에 new로 시작되는 메서드를 붙이지말고 @Autowired를 붙이면 된다.

@Service //서비스에 무조건 붙인다.

Controller는 되느냐 되지않느냐 입력이 되었느냐 되지않았느냐 등등을 확인하는 부분이라서
Service로직을 넣고 사용해서는 안된다!


2020-12-12==
**list에 있는 내장 메서드는 외워야한다.

# void 타입은 return이 없다.

생성자는 객체가 만들어지면서 딱 한번 실행이되는데 생성자를 썼기때문에 publicArticleService가 실행이되고
private ArticleRepository articleRepository;는 실행하면 NULL이 나오게된다.

데이터를 저장하면 램에 저장이되는데 db에 저장을해서 사용해야한다.
ArticleRepository에 있는 컴포넌트를 지우고 @Mapper로 수정한 후
class를 interface로 바꾼다.
 private int articleLastId;
  private List<Article> articles;
  public ArticleRepository(){
    articles = new ArrayList<>();
    articleLastId = 0;


  }

  public void makeTestDate() {

    for (int i = 1; i <= 10; i++) {
      String title = "제목" + i;
      String body = "내용" + i;

      writeArticle(title, body);
    }
  } 는 필요하지않기 때문에 지워주고
  @Mapper
  public interface ArticleRepository {

    public Article writeArticle(String title, String body);

    public Article getArticle(int id);

    public void deleteArticle(int id);
    public List<Article> getArticles();
    public void ModifyArticle(int id, String title, String body);
    }
    메서드 안에있던 내용들을 모두 지워준다.

마이바티스를 추가해야하는데 build.gradle을 클릭해서 들어가보면
implementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter:2.3.0'라고
마이바티스가 추가가 되어있다. -> 스프링이니셜라이즈를 했을때 미리 추가한것이다.
그래서 따로 다시 추가 할 필요는 없다.
마이 바티스를 사용하려면 마리아db가 필수이기때문에 함께 가져왔다.

결과적으로 마이바티스를 쓸것이지만 마리아db가 있어야 사용할 수 있기 때문에
마이바티스와 마리아db는 짝이라고 볼 수 있다.
ArticleService에 articleRepository.makeTestDate();가 오류가 생긴다.
이 부분은 이제 필요가 없기 때문에 지워줘도 된다.
왜? 데이터 베이스에 따로 저장할것이기 때문에 testdatabase는 필요없는것이다.
@Mapper
public interface ArticleRepository {

  // INSERT INTO article SET regDate = NOW(), updateDate = NOW(), title = ?, `body` = ?
  public Article writeArticle(String title, String body);

  // SELECE * FROM article WHERE id = ? 이라고 해야 id를 가져올 수 있다.
  public Article getArticle(int id);
  // DELETE FROM article WHERE id = ?
  public void deleteArticle(int id);

  // SELECT * FROM article ORDER BY id DESC;
  public List<Article> getArticles();

  // UPDATE article SET title = ?, `body` = ? updateDate = NOW() WHERE id = ?

  public void ModifyArticle(int id, String title, String body);
}
SELECT 같은 경우에는 마이바티스가 알아서 다 해주지만 마이바티스에게 힌트를 줘야한다.
mybatis select annotation이라고 구글에 검색한 후
@Select("SELECT * FROM article WHERE id = #{id}") 를 repository안의 select문 위에 붙여준다.
메서드가 실행이 되려면 해당 쿼리가 실행이 되는데 매개변수로 받은 아이디가 치환이된다.
db에 있는 데이터를 받아서 getArticle에 넣어주는 역할을 하는것이다.
http://localhost:8081/user/article/getArticle?id=1이라고 검색하고 로그인을 해주면
{"id":1,"title":"제목1","body":"내용1"}
이렇게 출력이되며 id4는 없기때문에 존재하지않는다는 문구가 뜨게된다.

자동 생성키/동적sql을 모른다면 mybatis select annotation // mybatis insert annotation 등 으로 검색해서 찾아볼 수 있다.
==ArticleRepository에 insert부분
@Insert("INSERT INTO Students (NAME, EMAIL ) VALUES (#{name},#{email})")
  // INSERT INTO article SET regDate = NOW(), updateDate = NOW(), title = ?, `body` = ?
  public Article writeArticle(String title, String body);
여기서 보면 return을 안해주기때문에
@Insert("INSERT INTO Students (NAME, EMAIL ) VALUES (#{name},#{email})")
  public void writeArticle(String title, String body);
  void로 바꿔준다.
    @Insert("INSERT INTO article SET regDate = NOW(), updateDate = NOW(), title = #{title}, `body` = #{body}")
    public Article writeArticle(String title, String body);
    미리 적어둔 sql문구를 적어주고 물음표란에 #{} 등을 잊어서는 안된다.

  @Select("SELECT LAST_INSERT_ID()")
  public int getLastInsertId();
} 를 따로 빼주는 작업을 했다.

------------------------------------------
json viewer라고 있는데 다운로드하면 편하게 볼 수 있다.

git 사용하다가 > 이런 모양의 화살표가 나오면 컨트롤c누르면 빠져나올 수 있다.

result data를 이용해서 중구남방되는 코드를 잡아줄것이다.

브라우져 -> 컨트롤러 -> 서비스 -> 리포지터리 -> DB(MyBatis에서 응답해주고있다.)

표준 보고서 양식을 만들것이다. 각 방향대로 응답할때의 양식을 쓴다.
양식이 지켜야 할 사항 :
- 성공인지 실패인지 쉽게 알 수 있어야한다. -> -1, -2로 나오면 안된다.
컨트롤러가 서비스에게 일을 시킬때 서로 학습을 하려면 서비스의 어떤 기능이 실행되느냐에 따라서 대비해야한다.
새 보고서 양식에는 명확하게 알 수 있어야한다.
무엇때문에 실패/성공했는지!


표준 통일 양식을 만든다 2022-12-14

=======================================
== 복습방법 ==
doAdd 부분적으로 지워서 다시 맞춰가면서 구현해봐야한다.
후에는 전체를 지우고 구현!
지우고 다시 만들어보는것이 중요하다.
지워보고 실행해보고 오류메시지를 읽어보면서 조금쓰고 수정해보고를 계속 반복해줘야한다.

== git == 2022-12-16
git checkout -f . :  가장 마지막에 커밋한 상태로 돌아간다.

ex.
예를들어 https://wiken.io/ken/10787필기 54강 내용으로 가려면 53강으로가서
https://github.com/SangWon7242/sb_app_2022_10_13/commit/7da3fe8bf80709a8a34f53d693acb2499d159bf0
7da3fe8bf80709a8a34f53d693acb2499d159bf0 이부분만 잘라서
git checkout -f 7da3fe8bf80709a8a34f53d693acb2499d159bf0 엔터 하게되면
이때의 프로젝트로 돌아가게된다.
db도 schema.sql에서 확인해서mariadb로 복사해와서 그 당시의 db로 셋팅을 다시해줘야한다.
최신상태로 다시 돌아오려면 git checkout -f master라고 해주면 된다.
개인 깃허브로 하기에는 한계가 있기 때문에
왠만하면 프로젝트를 2개로 돌리고 연습은 강사프젝에서
메인은 개인 프젝으로 하면된다.


==========================

    devtools:
      livereload:
        enabled: true 추가하면 즉각 새로고침이 가능!


============================
눈누(글꼴 받아오기) : https://noonnu.cc/font_page/767
제이쿼리(무조건 최상단에 둔다) : https://cdnjs.com/libraries/jquery
테일윈드(노멀라이즈, 라이브러리 : 노멀라이즈는 기본적으로 태그들이 모양이 희안한데 그걸 평범하게 만들어주는것) : https://tailwindcss.com/docs/installation/play-cdn
테일윈드 cheat sheet에 프론트 용어 검색하면 나온다 참고해서 만들것.
테일윈드 cheat sheet에 docs 클릭하면 어떻게 사용이되는지 확인 할 수 있다!

grow : 빈공간을 채우고 오른쪽으로 이동한다(상단 메뉴 이동할때 사용했다.)
flex items-center : 로고에 사용했고 중앙으로 오게된다.
mx-auto : 블럭요소 가운데로 정렬(container에 주로 사용)
mt : margin-top라고해서 위쪽 바깥쪽 여백을 주는것.
flex h-full items-center px-3 hover:underline : 수직 중앙정렬 후 마우스를 갖다댔을때 언더라인이 생기면서 클릭 할 수 있게 된다.
onclick="history.back()" : 클릭했을때 뒤로가기(버튼에서 <button type="button" "여기안에 작성">뒤로가기</button>)
<c:if test="false"> : 참이면 보여지고, 참이 아니면 안보여진다.


--------------------------
colgroup을 주고 col에 너비를 200 준것이다(list의 내용에 들어가는 부분)
<colgroup>
    <col width="200"/>
</colgroup>

-----------------
  @Select("""
      SELECT A.*,
      M.nickname AS extra__writeName
      FROM article AS A
      LEFT JOIN member AS M
      ON A.memberId = M.id
      ORDER BY id DESC
      """)
: 닉네임을 extra__writeName 으로 하고, article에서 집합을 찾는건데 멤버에서 아이디가 일치하면 멤버아이디를 A.id에 넣어주는것이다.
---------------------
두가지가 있다.
SELECT * FROM article; : 순수하게 article 게시물 보여주는것.
SELECT * FROM article; : json을 통해 추가적인 데이터를 가져올때.

------------------
 private void updateForPrintData(int actorId, Article article) { //(int actorId, Article article) : 로그인 한 사람이 누구인지 얻어오고, 해당 게시물을 얻어오는데
    if( article == null ) {
      return;                       // 게시물이 없으면 그대로 있는데 게시물이 있으면
    }
    ResultData actorCanDeleteRd = actorCanDelete(actorId, article);     //actorCanDelete에게 물어본다 해당아이디가 해당 게시물을 삭제 할 수 있는지.
    article.setExtra__actorCanDelete(actorCanDeleteRd.isSuccess());     //그러면 삭제 할 수 있는 가능성을 (actorCanDeleteRd.isSuccess())여기에 심어주는데
  }


------------------
Ut.jsReplace : replace로 된것은 바로뒤 뒤로가기가 안되고 맨처음 place로 가고 중간에 있던 place는 소멸된다.
do로 시작되는 페이지는 머물 수 있는 페이지가 아니다. 잠깐 있는 페이지 이다.
결제 페이지에서 삭제로가고 마지막에 리스트 페이지로 가는데,
뒤로가기를 해서 삭제로 가게되면 결제가 두번되니까 그것을 방지하기 위함

------------------
 public ResultData<Article>의 ResultData<Article>는 결과를 확인하기 위해 만든것이지 ajax 실제로는

 getForPrintArticles
 getArticles -> getForPrintArticle와 getArticles는 차이가 있다.

 getForPrintArticle -> innerJoin해서 추가정보 추가해주고, 현재 로그인 한 회원 가져와서 그 회원이 수정이나 삭제할 수 있는 정보까지 여기(getForPrintArticle)에 넘겨준 상태라고 보면 된다.
 getArticle -> 단순쿼리 SELECT * FROM article;이런식으로 데이터를 받아온다.
-------------------
UserArticleController라인에 변동사항*

HttpSession httpSession 이나

아래에
boolean isLogined = false;
int loginedMemberId = 0;
if (httpSession.getAttribute("loginedMemberId") != null) {
isLogined = true;
loginedMemberId = (int) httpSession.getAttribute("loginedMemberId");
}
이러한 문법이 중복되어 많이 사용되고있는데
request를 조금 더 쉽게 사용 할 수 있는 문법인 RQ를 사용 할 것이다.

HttpSession -> HttpServletRequest req 로 변경
isLogined -> rq.isLogined() 로 변경

boolean isLogined = false;
int loginedMemberId = 0;
if (httpSession.getAttribute("loginedMemberId") != null) {
isLogined = true;
loginedMemberId = (int) httpSession.getAttribute("loginedMemberId");
} -> Rq rq = new Rq(req); 로 변경
-----------------------

interceptor는 컨트롤러 이전에 실행되는것.
-----------------------
2022-12-21 95강의 이론 확인


@Override
  public boolean preHandle(HttpServletRequest req, HttpServletResponse resp, Object handle) throws Exception {
    System.out.println("실행되니?");  // 리스트 버튼 누르면 실행되는부분.
    Rq rq = new Rq(req);
    req.setAttribute("rq", rq);

    return HandlerInterceptor.super.preHandle(req, resp, handle);
  }
--------
UserArticleController의
  Rq rq = new Rq(req); 를 모두
  Rq rq = (Rq) req.getAttribute("rq"); 로 바꿔줬다.